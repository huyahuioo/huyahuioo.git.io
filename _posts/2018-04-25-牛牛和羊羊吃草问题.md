题目描述如下：
>牛牛和羊羊共吃一堆青草，牛牛先吃。吃草的规则为，一次只能吃4的整数次幂，如 1、4、16、64...牛牛羊羊轮流吃，谁最后能把草一次吃完谁赢得比赛。现在给出一堆草的数量，牛牛和羊羊都按照规则并且按照最优的方法去吃，问谁能赢？` 

####递归的解法 
 刚看到这题目的时候，第一反应就是和两个人轮流捡石子，一次只能捡1、2、3个石子blabla...的题目一样,捡石子的解为`f(n) = !(f(n-1) || f(n-2) || f(n-3))`。但是这一题的情况看似类似，实则差别很大，因为 f(n) 依赖于f(n)自身、f(n-1)、f(n-4)、f(n-16)、f(n-64)......，递推关系的依赖的状态太多。如果使用递归，直接爆炸。因此<font color=red>**递归的解法行不通**</font>。 

####非递归的解法 

请看这位基友的分析:
<font size=5>https://blog.csdn.net/qq_27576655/article/details/80048800</font>
 
 在此基础上，我发挥了一下想象力，继续总结一点我的想法。
 **1.吃草规则的简化**

 吃4的整数次幂1、16、64、256、...，尾数有3种情况：1、4、6，模5之后只有1和4两种情况。即**一次只能吃1 (mod 5) 或 4 (mod 5)数量的草**。
 
 **2.基于简化后的吃草规则，面对数量为R的草堆，应该怎么吃**
 
 面对<font color=red>**R==0（mod 5）**</font>的情况，牛牛只能吃1（mod 5）或4（mod 5），因此牛牛吃完后，剩余的草量只能为1（mod 5）或4（mod 5），对于两种情况，羊羊都能在吃完之后使剩余数量为0（mod 5）。因此羊羊可以做到：使牛牛始终面临的草量都为 0（mod 5），其一种特殊情况即 0，因此这种情况牛牛必输。
 面对<font color=red>**R==1（mod 5）或R==4（mod 5）**</font>的情况，牛牛都可以把草的数量变为0（mod 5），而羊羊面对0（mod 5）的草堆必输，因此牛牛必赢。 
 面对<font color=red>**R==2（mod 5）**</font>的情况，牛牛只能把草的数量变为**1（mod 5）或者3（mod 5）**，此时他当然只能选择3（mod 5），如此羊羊可以选择吃1（mod 5）个草来使得R==2（mod 5)，因此羊羊可以做到：使牛牛始终面临的草量都为2（mod 5），其中特殊情况即2，因此牛牛必输。 
 面对<font color=red>**R==3（mod 5）**</font>的情况，牛牛可以吃1（mod 5）个草，使得羊羊必输，因此牛牛必赢。
因此可以得出：
R==0（mod 5）或R==2（mod 5）时牛牛必输；
R==1（mod 5）或R==3（mod 5）或R==4（mod 5）时，牛牛必赢。

